{
  "name": "csv",
  "version": "0.0.9",
  "description": "CSV parser with simple api, full of options and tested against large datasets.",
  "author": {
    "name": "David Worms",
    "email": "david@adaltas.com"
  },
  "contributors": [
    {
      "name": "David Worms",
      "email": "david@adaltas.com"
    },
    {
      "name": "Will White",
      "email": "https://github.com/willwhite"
    },
    {
      "name": "Justin Latimer",
      "email": "https://github.com/justinlatimer"
    }
  ],
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/csv",
  "engines": {
    "node": ">= 0.1.90"
  },
  "keywords": [
    "parser",
    "csv"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/wdavidw/node-csv-parser.git"
  },
  "readme": "<pre>\n _   _           _        _____  _______      __ _____  \n| \\ | |         | |      / ____|/ ____\\ \\    / /|  __ \\  \n|  \\| | ___   __| | ___ | |    | (___  \\ \\  / / | |__) |_ _ _ __ ___  ___ _ __ \n| . ` |/ _ \\ / _` |/ _ \\| |     \\___ \\  \\ \\/ /  |  ___/ _` | '__/ __|/ _ \\ '__|\n| |\\  | (_) | (_| |  __/| |____ ____) |  \\  /   | |  | (_| | |  \\__ \\  __/ |  \n|_| \\_|\\___/ \\__,_|\\___| \\_____|_____/    \\/    |_|   \\__,_|_|  |___/\\___|_|  \n\n</pre>\n\nThis project provide CSV parsing and has been tested and used on large source file (over 2Gb).\n\n-   Support delimiter, quote and escape characters\n-   Line breaks discovery: line breaks in source are detected and reported to destination\n-   Data transformation\n-   Asynch and event based\n-   Support for large datasets\n-   Complete test coverage as sample and inspiration\n\nQuick example\n-------------\n\nUsing the library is a 4 steps process:\n\n1.\tCreate a source\n2.\tCreate a destination (optional)\n3.\tTransform the data (optional)\n4.  Listen to events (optional)\n\nHere is a example:\n\n\t// node samples/sample.js\n\tvar csv = require('csv');\n\t\n\tcsv()\n\t.fromPath(__dirname+'/sample.in')\n\t.toPath(__dirname+'/sample.out')\n\t.transform(function(data){\n\t\tdata.unshift(data.pop());\n\t\treturn data;\n\t})\n\t.on('data',function(data,index){\n\t\tconsole.log('#'+index+' '+JSON.stringify(data));\n\t})\n\t.on('end',function(count){\n\t\tconsole.log('Number of lines: '+count);\n\t})\n\t.on('error',function(error){\n\t\tconsole.log(error.message);\n\t});\n\t\n\t// Print sth like:\n\t// #0 [\"2000-01-01\",\"20322051544\",\"1979.0\",\"8.8017226E7\",\"ABC\",\"45\"]\n\t// #1 [\"2050-11-27\",\"28392898392\",\"1974.0\",\"8.8392926E7\",\"DEF\",\"23\"]\n\t// Number of lines: 2\n\nInstalling\n----------\n\nVia git (or downloaded tarball):\n\n    $ git clone http://github.com/wdavidw/node-csv-parser.git\n\nThen, simply copy or link the ./lib/csv.js file into your $HOME/.node_libraries folder or inside a declared path folder.\n\nVia [npm](http://github.com/isaacs/npm):\n\n    $ npm install csv\n\nReading API\n-----------\n\nThe following method are available:\n\n-   *fromPath*    \n    Take a file path as first argument and optionally on object of options as a second arguments.\n    \n-   *fromStream*    \n    Take a readable stream as first argument and optionally on object of options as a second arguments.\n    \n-   *from*    \n    Take a string, a buffer, an array or an object as first argument and optionally some options as a second arguments.\n\nOptions are:\n\n-   *delimiter*    \n    Set the field delimiter, one character only, default to comma.\n    \n-   *quote*    \n    Set the field delimiter, one character only, default to double quotes.\n    \n-   *escape*    \n    Set the field delimiter, one character only, default to double quotes.\n    \n-   *columns*    \n    List of fields or true if autodiscovered in the first CSV line, impact the `transform` argument and the `data` event by providing an object instead of an array, order matters, see the transform and the columns section below.\n\t\n-   *trim*    \n    If true, ignore whitespace immediately around the delimiter, default to false.\n\t\n-   *ltrim*    \n    If true, ignore whitespace immediately following the delimiter (i.e. left-trim all fields), default to false.\n\t\n-   *rtrim*    \n    If true, ignore whitespace immediately preceding the delimiter (i.e. right-trim all fields), default to false.\n\nWriting API\n-----------\n\nThe following method are available:\n\n-   *write*    \n    Take a string, an array or an object, implementation of the StreamWriter API.\n\t\n-   *end*    \n    Terminate the stream, implementation of the StreamWriter API.\n    \n-   *toPath*    \n    Take a file path as first argument and optionally on object of options as a second arguments.\n    \n-   *toStream*    \n    Take a readable stream as first argument and optionally on object of options as a second arguments.\n\nOptions are:\n\n-   *delimiter*    \n    Default to the delimiter read option.\n    \n-   *quote*    \n    Default to the quote read option.\n    \n-   *escape*    \n    Default to the escape read option.\n    \n-   *columns*    \n    List of fields, apply when `transform` return an object, order matters, see the transform and the columns sections below.\n    \n-   *encoding*    \n    Default to 'utf8', apply when a writable stream is created.\n    \n-   *lineBreaks*    \n    String used to delimit record rows or a special value; special values are 'auto', 'unix', 'mac', 'windows', 'unicode'; default to 'auto' (discovered in source).\n    \n-   *flag*    \n    Default to 'w', 'w' to create or overwrite an file, 'a' to append to a file. Apply when using the `toPath` method.\n    \n-   *bufferSize*    \n    Internal buffer holding data before being flush into a stream. Apply when destination is a stream.\n    \n-   *end*    \n    Prevent calling `end` on the destination, so that destination is no longer writable, similar to passing `{end: false}` option in `stream.pipe()`.\n\nTransforming data\n-----------------\n\nYou may provide a callback to the `transform` method. The contract is quite simple, you receive an array of fields for each record and return the transformed record. The return value may be an array, an associative array, a string or null. If null, the record will simply be skipped.\n\nUnless you specify the `columns` read option, `data` are provided as arrays, otherwise they are objects with keys matching columns names.\n\nWhen the returned value is an array, the fields are merge in order. When the returned value is an object, it will search for the `columns` property in the write or in the read options and smartly order the values. If no `columns` options are found, it will merge the values in their order of appearance. When the returned value is a string, it directly sent to the destination source and it is your responsibility to delimit, quote, escape or define line breaks.\n\nExample of transform returning a string\n\n\t// node samples/transform.js\n\tvar csv = require('csv');\n\t\n\tcsv()\n\t.fromPath(__dirname+'/transform.in')\n\t.toStream(process.stdout)\n\t.transform(function(data,index){\n\t\treturn (index>0 ? ',' : '') + data[0] + \":\" + data[2] + ' ' + data[1];\n\t});\n\t\n\t// Print sth like:\n\t// 82:Zbigniew Preisner,94:Serge Gainsbourg\n\nEvents\n------\n\nBy extending the Node `EventEmitter` class, the library provide a few useful events:\n\n-\t*data* (function(data, index){})\n    Thrown when a new row is parsed after the `transform` callback and with the data being the value returned by `transform`. Note however that the event won't be call if transform return `null` since the record is skipped.\n\tThe callback provide two arguments:\n\t`data` is the CSV line being processed (by default as an array)\n\t`index` is the index number of the line starting at zero\n    \n-   *end*\n    In case your redirecting the output to a file using the `toPath` method, the event will be called once the writing process is complete and the file closed.\n    \n-   *error*\n    Thrown whenever an error is captured.\n\nColumns\n-------\n\nColumns names may be provided or discovered in the first line with the read options `columns`. If defined as an array, the order must match the input source. If set to `true`, the fields are expected to be present in the first line of the input source.\n\nYou can define a different order and even different columns in the read options and in the write options. If the `columns` is not defined in the write options, it will default to the one present in the read options. \n\nWhen working with fields, the `transform` method and the `data` events receive their `data` parameter as an object instead of an array where the keys are the field names.\n\n\t// node samples/column.js\n\tvar csv = require('csv');\n\t\n\tcsv()\n\t.fromPath(__dirname+'/columns.in',{\n\t\tcolumns: true\n\t})\n\t.toStream(process.stdout,{\n\t\tcolumns: ['id', 'name']\n\t})\n\t.transform(function(data){\n\t\tdata.name = data.firstname + ' ' + data.lastname\n\t\treturn data;\n\t});\n\t\n\t// Print sth like:\n\t// 82,Zbigniew Preisner\n\t// 94,Serge Gainsbourg\n\nRunning the tests\n-----------------\n\nTests are executed with expresso. To install it, simple use `npm install expresso`.\n\nTo run the tests\n\texpresso -I lib test/*\n\nTo develop with the tests watching at your changes\n\texpresso -w -I lib test/*\n\nTo instrument the tests\n\texpresso -I lib --cov test/*\n\nContributors\n------------\n\n*\tDavid Worms : <https://github.com/wdavidw>\n*\tWill White : <https://github.com/willwhite>\n*\tJustin Latimer : <https://github.com/justinlatimer>\n*\tjonseymour : <https://github.com/jonseymour>\n*\tpascalopitz : <https://github.com/pascalopitz>\n\nRelated projects\n----------------\n\n*   Pavel Kolesnikov \"ya-csv\": http://github.com/wdavidw/ya-csv\n*   Chris Williams \"node-csv\": http://github.com/voodootikigod/node-csv\n\n",
  "readmeFilename": "readme.md",
  "_id": "csv@0.0.9",
  "_from": "csv@0.0.9"
}
