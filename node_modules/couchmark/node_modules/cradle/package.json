{
  "name": "cradle",
  "version": "0.6.6",
  "description": "the high-level, caching, CouchDB library",
  "url": "http://cloudhead.io/cradle",
  "keywords": [
    "couchdb",
    "database",
    "couch"
  ],
  "author": {
    "name": "Alexis Sellier",
    "email": "self@cloudhead.net"
  },
  "contributors": [
    {
      "name": "Charlie Robbins",
      "email": "charlie@nodejitsu.com"
    },
    {
      "name": "Maciej Malecki",
      "email": "maciej@nodejitsu.com"
    }
  ],
  "main": "./lib/cradle",
  "dependencies": {
    "follow": "0.8.x",
    "request": "2.x.x",
    "vargs": "0.1.0"
  },
  "devDependencies": {
    "async": "~0.1.x",
    "vows": "0.6.x"
  },
  "scripts": {
    "test": "node test/helpers/seed.js && vows --spec"
  },
  "engines": {
    "node": ">=0.6.0"
  },
  "readme": "cradle\n======\n\nA high-level, caching, CouchDB client for Node.js\n\nintroduction\n------------\n\nCradle is an asynchronous javascript client for [CouchDB](http://couchdb.apache.org).\nIt is somewhat higher-level than most other CouchDB clients, requiring a little less knowledge of CouchDB's REST API.\nCradle also has built-in write-through caching, giving you an extra level of speed, and making document _updates_ and _deletion_ easier.\nCradle was built from the love of CouchDB and Node.js, and tries to make the most out of this wonderful marriage of technologies.\n\nphilosophy\n----------\n\nThe key concept here is the common ground shared by CouchDB and Node.js, that is, _javascript_. The other important aspect of this marriage is the asynchronous behaviors of both these technologies. Cradle tries to make use of these symmetries, whenever it can.\nCradle's API, although closely knit with CouchDB's, isn't overly so. Whenever the API can be abstracted in a friendlier, simpler way, that's the route it takes. So even though a large part of the `Cradle <--> CouchDB` mappings are one to one, some Cradle functions, such as `save()`, can perform more than one operation, depending on how they are used.\n\nsynopsis\n--------\n\n``` js\n  var cradle = require('cradle');\n  var db = new(cradle.Connection)().database('starwars');\n\n  db.get('vader', function (err, doc) {\n      doc.name; // 'Darth Vader'\n      assert.equal(doc.force, 'dark');\n  });\n\n  db.save('skywalker', {\n      force: 'light',\n      name: 'Luke Skywalker'\n  }, function (err, res) {\n      if (err) {\n          // Handle error\n      } else {\n          // Handle success\n      }\n  });\n```\n\ninstallation\n------------\n\n``` bash\n  $ npm install cradle\n```\n\nAPI\n---\n\nCradle's API builds right on top of Node's asynch API. Every asynch method takes a callback as its last argument. The return value is an `event.EventEmitter`, so listeners can also be optionally added.\n\n### Opening a connection ###\n\n``` js\n  new(cradle.Connection)('http://living-room.couch', 5984, {\n      cache: true,\n      raw: false\n  });\n```\n\n_Defaults to `127.0.0.1:5984`_\n\nNote that you can also use `cradle.setup` to set a global configuration:\n\n``` js\n  cradle.setup({\n    host: 'living-room.couch',\n    cache: true,\n    raw: false\n  });\n\n  var c = new(cradle.Connection),\n     cc = new(cradle.Connection)('173.45.66.92');\n```\n\n### creating a database ###\n\n``` js\n  var db = c.database('starwars');\n  db.create();\n```\n\n#### checking for database existence ####\n\nYou can check if a database exists with the `exists()` method.\n\n``` js\n  db.exists(function (err, exists) {\n    if (err) {\n      console.log('error', err);\n    } else if (exists) {\n      console.log('the force is with you.');\n    } else {\n      console.log('database does not exists.');\n      db.create();\n      /* populate design documents */\n    }\n  });\n```\n\n### destroy a database ###\n\n``` js\n  db.destroy(cb);\n```\n\n### fetching a document _(GET)_ ###\n\n``` js\n  db.get('vader', function (err, doc) {\n      console.log(doc);\n  });\n```\n\n> If you want to get a specific revision for that document, you can pass it as the 2nd parameter to `get()`.\n\nCradle is also able to fetch multiple documents if you have a list of ids, just pass an array to `get`:\n\n``` js\n  db.get(['luke', 'vader'], function (err, doc) { ... });\n```\n\n### Querying a view ###\n\n``` js\n  db.view('characters/all', function (err, res) {\n      res.forEach(function (row) {\n          console.log(\"%s is on the %s side of the force.\", row.name, row.force);\n      });\n  });\n```\n\nYou can access the key and value of the response with forEach using two parameters. An optional third parameter will return the id like this example.\n\n``` js\n  db.view('characters/all', function (err, res) {\n      res.forEach(function (key, row, id) {\n          console.log(\"%s has view key %s.\", row.name, key);\n      });\n  });\n```\n\nTo use [View Generation Options](http://wiki.apache.org/couchdb/HTTP_view_API#View_Generation_Options) you can use the view Method with three parameters (viewname, options, callback):\n\n``` js\n  db.view('characters/all', {group: true, reduce: true} , function (err, res) {\n      res.forEach(function (row) {\n          console.log(\"%s is on the %s side of the force.\", row.name, row.force);\n      });\n  });\n```\n\n#### Querying a row with a specific key ####\nLets suppose that you have a design document that you've created:\n\n``` js\n  db.save('_design/user', {\n    views: {\n      byUsername: {\n        map: 'function (doc) { if (doc.resource === 'User') { emit(doc.username, doc) } }'\n      }\n    }\n  });\n```\n\nIn CouchDB you could query this view directly by making an HTTP request to:\n\n```\n  /_design/User/_view/byUsername/?key=\"luke\"\n```\n\nIn `cradle` you can make this same query by using the `.view()` database function:\n\n``` js\n  db.view('user/byUsername', { key: 'luke' }, function (err, doc) {\n      console.dir(doc);\n  });\n```\n\n#### Querying a view with an array key\n\nSay you create view for cars that has an array key with make and model\n``` js\ndb.save('_design/cars', {\n  views: {\n    byMakeAndModel: {\n      map: function (doc) {\n        if (doc.resource === 'Car' && doc.make && doc.model) {\n          var key = [doc.make, doc.model]\n          emit(key, doc)\n        }\n      }\n    }\n  }\n})\n```\nIf you want all the cars made by *Ford* with a model name between *Rav4* and later (alphabetically sorted).\nIn CouchDB you could query this view directly by making an HTTP request to:\n```\n  /_design/User/_view/byMakeAndModel/?startkey=[\"Ford\"]&endkey=[\"Ford\", \"\\u9999\"]\n```\n\nIn `cradle` you can make this same query by using the `.view()` database function with `startkey` and `endkey` options.\n\n``` js\nvar util = require('util')\nvar opts = {\n  startkey: ['Ford'],\n  endkey: ['Ford', '\\u9999']\n}\ndb.view('cars/', opts, function (err, docs) {\n  if (err) {\n    util.error(err)\n    return\n  }\n  util.debug(docs)\n});\n```\n In the options object you can also optionally specify whether or not to `group` and `reduce` the output. In this example `reduce` must be false since there is no reduce function defined for the `cars/byMakeAndModel`. With grouping and reducing the options object would look like:\n``` js\nvar opts = {\n  startkey: ['Ford'],\n  endkey: ['Ford', '\\u9999'],\n  group: true,\n  reduce: true\n}\n```\n\n### creating/updating documents ###\n\nIn general, document creation is done with the `save()` method, while updating is done with `merge()`.\n\n#### creating with an id _(PUT)_ ####\n\n``` js\n  db.save('vader', {\n      name: 'darth', force: 'dark'\n  }, function (err, res) {\n      // Handle response\n  });\n```\n\n#### creating without an id _(POST)_ ####\n\n``` js\n  db.save({\n      force: 'dark', name: 'Darth'\n  }, function (err, res) {\n      // Handle response\n  });\n```\n\n#### updating an existing document with the revision ####\n\n``` js\n  db.save('luke', '1-94B6F82', {\n      force: 'dark', name: 'Luke'\n  }, function (err, res) {\n      // Handle response\n  });\n```\n\nNote that when saving a document this way, CouchDB overwrites the existing document with the new one. If you want to update only certain fields of the document, you have to fetch it first (with `get`), make your changes, then resave the modified document with the above method.\n\nIf you only want to update one or more attributes, and leave the others untouched, you can use the `merge()` method:\n\n``` js\n  db.merge('luke', {jedi: true}, function (err, res) {\n      // Luke is now a jedi,\n      // but remains on the dark side of the force.\n  });\n```\n\nNote that we didn't pass a `_rev`, this only works because we previously saved a full version of 'luke', and the `cache` option is enabled.\n\n#### bulk insertion ####\n\nIf you want to insert more than one document at a time, for performance reasons, you can pass an array to `save()`:\n\n``` js\n  db.save([\n      { name: 'Yoda' },\n      { name: 'Han Solo' },\n      { name: 'Leia' }\n  ], function (err, res) {\n      // Handle response\n  });\n```\n\n#### creating views ####\n\nHere we create a design document named 'characters', with two views: 'all' and 'darkside'.\n\n``` js\n  db.save('_design/characters', {\n      all: {\n          map: function (doc) {\n              if (doc.name) emit(doc.name, doc);\n          }\n      },\n      darkside: {\n          map: function (doc) {\n              if (doc.name && doc.force == 'dark') {\n                  emit(null, doc);\n              }\n          }\n      }\n  });\n```\n\nThese views can later be queried with `db.view('characters/all')`, for example.\n\nHere we create a temporary view. WARNING: do not use this in production as it is\nextremely slow (use it to test views).\n\n``` js\n  db.temporaryView({\n      map: function (doc) {\n        if (doc.color) emit(doc._id, doc);\n      }\n    }, function (err, res) {\n      if (err) console.log(err);\n      console.log(res);\n  });\n```\nNote: If you must use [View Generation Options](http://wiki.apache.org/couchdb/HTTP_view_API#View_Generation_Options) on your temporary view you can use the three parameter version of the temporaryView() Method - similar to the one described above.\n\n### creating validation ###\n\nwhen saving a design document, cradle guesses you want to create a view, mention views explicitly to work around this.\n\n``` js\n  db.save('_design/laws', {\n    views: {},\n    validate_doc_update:\n      function (newDoc, oldDoc, usrCtx) {\n        if (! /^(light|dark|neutral)$/.test(newDoc.force))\n          throw { error: \"invalid value\", reason:\"force must be dark, light, or neutral\" }\n      }\n    }\n  });\n```\n\n### removing documents _(DELETE)_ ###\n\nTo remove a document, you call the `remove()` method, passing the latest document revision.\n\n``` js\n  db.remove('luke', '1-94B6F82', function (err, res) {\n      // Handle response\n  });\n```\n\n\nIf `remove` is called without a revision, and the document was recently fetched from the database, it will attempt to use the cached document's revision, providing caching is enabled.\n\nConnecting with authentication and SSL\n--------------------------------------\n\n``` js\n  var connection = new(cradle.Connection)('https://couch.io', 443, {\n      auth: { username: 'john', password: 'fha82l' }\n  });\n```\n\nor\n\n``` js\n  var connection = new(cradle.Connection)('couch.io', 443, {\n      secure: true,\n      auth: { username: 'john', password: 'fha82l' }\n  });\n```\n\nRetry on Connection Issues\n--------------------------\n\nFor a unreliable connection, you can have non-streaming queries automatically retry:\n\n``` js\n  var connection = new(cradle.Connection)('couch.io', 443, {\n      retries: 3,\n      retryTimeout: 30 * 1000\n  });\n```\n\nChanges API\n-----------\n\nFor a one-time `_changes` query, simply call `db.changes` with a callback:\n\n``` js\n  db.changes(function (err, list) {\n      list.forEach(function (change) { console.log(change) });\n  });\n```\n\nOr if you want to see changes since a specific sequence number:\n\n``` js\n  db.changes({ since: 42 }, function (err, list) {\n      ...\n  });\n```\n\nThe callback will receive the list of changes as an *Array*. If you want to include\nthe affected documents, simply pass `include_docs: true` in the options.\n\n### Streaming #\n\nYou can also *stream* changes, by calling `db.changes` without the callback. This API uses the **excellent** [follow][0] library from [IrisCouch][1]:\n\n``` js\n  var feed = db.changes({ since: 42 });\n\n  feed.on('change', function (change) {\n      console.log(change);\n  });\n```\n\nIn this case, it returns an instance of `follow.Feed`, which behaves very similarly to node's `EventEmitter` API. For full documentation on the options available to you when monitoring CouchDB with `.changes()` see the [follow documentation][0].\n\nAttachments\n-----------\nCradle supports writing, reading, and removing attachments. The read and write operations can be either buffered or streaming\n## Writing ##\nYou can buffer the entire attachment body and send it all at once as a single request. The callback function will fire after the attachment upload is complete or an error occurs\n\n**Syntax**\n```js\ndb.saveAttachment(idData, attachmentData, callbackFunction)\n```\n**Example**\nSay you want to save a text document as an attachment with the name 'fooAttachment.txt' and the content 'Foo document text'\n``` js\nvar doc = <some existing document>\nvar id = doc._id\nvar rev = doc._rev\nvar idAndRevData = {\n  id: id,\n  rev: rev\n}\nvar attachmentData = {\n  name: 'fooAttachment.txt',\n  'Content-Type': 'text/plain',\n  body: 'Foo document text'\n}\ndb.saveAttachment(idAndRevData, attachmentData, function (err, reply) {\n  if (err) {\n    console.dir(err)\n    return\n  }\n  console.dir(reply)\n})\n```\n\n\n### Streaming ###\nYou can use a read stream to upload the attachment body rather than buffering the entire body first. The callback function will fire after the streaming upload completes or an error occurs\n\n**Syntax**\n```js\nvar doc = savedDoc // <some saved couchdb document which has an attachment>\nvar id = doc._id\nvar rev = doc._rev\nvar idAndRevData = {\n  id: id,\n  rev: rev\n}\nvar attachmentData = {\n  name: attachmentName               // something like 'foo.txt'\n  'Content-Type': attachmentMimeType // something like 'text/plain', 'application/pdf', etc.\n  body: rawAttachmentBody            // something like 'foo document body text'\n}\nvar readStream = fs.createReadStream('/path/to/file/')\nvar writeStream  = db.saveAttachment(idData, attachmentData, callbackFunction)\nreadStream.pipe(writeStream)\n```\nWhen the streaming upload is complete the callback function will fire\n\n\n**Example**\nAttach a pdf file with the name 'bar.pdf' located at path './data/bar.pdf' to an existing document\n\n```js\nvar path = require('path')\nvar fs = require('fs')\n// this document should already be saved in the couchdb database\nvar doc = {\n  _id: 'fooDocumentID',\n  _rev: 'fooDocumentRev'\n}\nvar idData = {\n  id: doc._id,\n  rev: doc._rev\n}\nvar filename = 'bar.pdf' // this is the filename that will be used in couchdb. It can be different from your source filename if desired\nvar filePath = path.join(__dirname, 'data', 'bar.pdf')\nvar readStream = fs.createReadStream\n// note that there is no body field here since we are streaming the upload\nvar attachmentData = {\n  name: 'fooAttachment.txt',\n  'Content-Type': 'text/plain'\n}\ndb.saveAttachment(idData, attachmentData, function (err, reply) {\n  if (err) {\n    console.dir(err)\n    return\n  }\n  console.dir(reply)\n}, readStream)\n```\n\n\n## Reading ##\n\n\n### Buffered\nYou can buffer the entire attachment and receive it all at once. The callback function will fire after the download is complete or an error occurs. The second parameter in the callback will be the binary data of the attachment\n\n**Syntax**\n```js\ndb.getAttachment(documentID, attachmentName, callbackFunction)\n```\n**Example**\n Say you want to read back an attachment that was saved with the name 'foo.txt'\n```js\nvar doc = <some saved document that has an attachment with name *foo.txt*>\nvar id = doc._id\nvar attachmentName = 'foo.txt'\ndb.getAttachment(id, attachmentName, function (err, reply) {\n  if (err) {\n    console.dir(err)\n    return\n  }\n  console.dir(reply)\n})\n```\n\n### Streaming\nYou can stream the attachment as well. If the attachment is large it can be useful to stream it to limit memory consumption. The callback function will fire once the download stream is complete. Note that there is only a single error parameter passed to the callback function. The error is null is no errors occured or an error object if there was an error downloading the attachment. There is no second parameter containing the attachment data like in the buffered read example\n\n**Syntax**\n```js\nvar readStream = db.getAttachment(documentID, attachmentName, callbackFunction)\n```\n\n**Example**\n Say you want to read back an attachment that was saved with the name 'foo.txt'. However the attachment foo.txt is very large so you want to stream it to disk rather than buffer the entire file into memory\n```js\nvar doc = <some saved document that has an attachment with name *foo.txt*>\nvar id = doc._id\nvar attachmentName = 'foo.txt'\nvar downloadPath = path.join(__dirname, 'foo_download.txt')\nvar writeStream = fs.createWriteStream(downloadPath)\nvar readStream = db.getAttachment('piped-attachment', 'foo.txt', function (err) { // note no second reply paramter\n  if (err) {\n    console.dir(err)\n    return\n  }\n  console.dir('download completed and written to file on disk at path', downloadPath)\n})\nreadStream.pipe(writeStream)\n```\n## Removing\nYou can remove uploaded attachments with a _id and an attachment name\n\n**Syntax**\n```js\ndb.removeAttachment(documentID, attachmentName, callbackFunction)\n```\n**Example**\n Say you want to remove an attachment that was saved with the name 'foo.txt'\n```js\nvar doc = <some saved document that has an attachment with name *foo.txt*>\nvar id = doc._id\nvar attachmentName = 'foo.txt'\ndb.removeAttachment(id, attachmentName, function (err, reply) {\n  if (err) {\n    console.dir(err)\n    return\n  }\n  console.dir(reply)\n})\n```\nOther API methods\n-----------------\n\n### CouchDB Server level ###\n\n``` js\n  new(cradle.Connection)().*\n```\n\n- `databases()`: Get list of databases\n- `config()`: Get server config\n- `info()`: Get server information\n- `stats()`: Statistics overview\n- `activeTasks()`: Get list of currently active tasks\n- `uuids(count)`: Get _count_ list of UUIDs\n- `replicate(options)`: Replicate a database.\n\n### database level ###\n\n``` js\n  new(cradle.Connection)().database('starwars').*\n```\n\n- `info()`: Database information\n- `all()`: Get all documents\n- `compact()`: Compact database\n- `viewCleanup()`: Cleanup old view data\n- `replicate(target, options)`: Replicate this database to `target`.\n\n[0]: https://github.com/iriscouch/follow\n[1]: http://iriscouch.com\n\n\nTesting\n-------\n\nAfter cloning the repo and installing all dependencies (using `npm install`) you can run all tests using [vows](http://vowsjs.org):\n\n```\n$ node test/helpers/seed.js\n$ vows --spec\n```\n",
  "readmeFilename": "README.md",
  "_id": "cradle@0.6.6",
  "_from": "cradle@~0.6.6"
}
